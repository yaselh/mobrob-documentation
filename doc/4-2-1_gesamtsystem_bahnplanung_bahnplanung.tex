Die gesamte Bahnplanungskomponente besteht aus zwei Paketen, vgl. Abbildung \ref{SysArchitectur}:
\begin{enumerate}
	\item \textit{cup\_acceptor\_planning}:
				\newline
				Erhält von der Highlevel-Steuerung die Posen der Tasse und des Turtlebots. Setzt Zwischenwegpunkt für die Trajektorienbestimmung. Regelt den Ablauf zwischen der Steuerung des UR5 und des PG70.
	\item \textit{cup\_acceptor\_pathing}:
				\newline
				Initialisiert MoveIt. Erhält von \textit{cup\_acceptor\_planning} eine Liste von Wegpunkten. Bestimmt mit auszuführende Trajektorie für die gegebenen Wegpunkt und führt sie auf dem UR5 aus.
\end{enumerate}
\textit{cup\_acceptor\_planning} stellt die Logik hinter der Bahnplanung dar. Sie startet Actions von \textit{cup\_acceptor\_pathing}, sowie \textit{cup\_gripper} und regelt das Zusammenspiel dieser beiden ROS-Pakete. Der eigentliche Bahnplanungsablauf ist in fünf Etappen unterteilt:
\begin{enumerate}
	\item Sicherstellung, dass sich der UR5 samt PG70 in Home-Konfiguration befindet.
	\item Führung des PG70 mit dem UR5 zur Tasse mit einem Zwischenwegpunkt einige Zentimeter über dem eigentlichen Ziel. Schließen des PG70 zum Greifen der Tasse.
	\item Führung des PG70, welcher die Tasse greift, mit dem UR5 zum Turtlebot. Dabei werden zwei Zwischenwegpunkte gesetzt: einer über der Tasse und einer über dem Turtlebot einige Zentimeter über der Tischplatte. Öffnen des PG70 zum Loslassen der Tasse.
	\item Führung des PG70 mit dem UR5 von der Turtlebot-Position horizontal in die Höhe bis auf einige Zentimeter über der Tischplatte.
	\item Sicherstellung, dass sich der UR5 samt PG70 in Home-Konfiguration befindet.
\end{enumerate}
\textit{cup\_acceptor\_planning} stellt eine einzige Action bereit, welche die oben beschriebene Logik ausführt. Der erste und letzte Schritt scheint redundant, ist jedoch wichtig, damit der Roboterarm während der Lokalisierung der Tasse nicht unnötigerweise in das Kinect-Bild hineinragt. Weiterhin sind die Zwischenwegpunkte notwendig, um die Bahnplanung zu optimieren, zu beschleunigen und eine aufrechte Haltung der Tasse auch ohne Pfad-Constraints zu gewährleisten. Außerdem wurde der Tisch in Zonen unterteilt und überprüft, ob sich die Arm-Basis im direkten Pfad zwischen der Tasse und dem Turtlebot befindet. Ist dies nämlich der Fall oder steht die Tasse in bestimmten Zonen, so müssen manuell Umgehungspunkte gesetzt werden. Diese verhindern, dass der EEF des UR5 direkt über die Arm-Basis gefahren wird.
%Zunächst stellt sie sicher, dass der Roboterarm samt PG70 sich in Home-Konfiguration befinden. Danach wird zunächst der UR5 zur Tasse bewegt. Dann wird der PG70 angesteuert, um die Tasse zu greifen. Anschließend wird die Tasse zum Turtlebot geführt und dort wieder losgelassen. Letztendlich soll der Roboterarm wieder in die Home-Konfiguration zurückkehren. Für den Bahnplanungsablauf wird von \textit{cup\_acceptor\_planning} dabei neben den Posen der Tasse und des Turtlebots auch noch je ein Punkt direkt über den beiden Zielen gesetzt und zwar so, dass sich der EEF des Roboterarms einige Zentimeter über der oberen Kante der Tasse bzw. der Tischplatte befindet. \textit{cup\_acceptor\_planning} stellt eine einzige Action bereit, welche die oben beschriebene Logik ausführt. 
\newline \\
\textit{cup\_acceptor\_pathing} ist für die eigentliche Bahnplanung und Ansteuerung der Hardware mit MoveIt zuständig. Da wir die Bahnplanung in Python implementierten, mussten wir das ROS-Paket \glqq Moveit\_Commander\grqq, siehe \cite{MoveItCommander}, zu unserem Projekt hinzufügen. \textit{cup\_acceptor\_pathing} erhält also eine Liste von EEF-Posen, über die es eine Trajektorie berechnen soll, welche vom UR5 ohne Kollisionen abgefahren werden kann. Dazu wird MoveIt verwendet. MoveIt stellt dabei einen kollisionsfreien Pfad sicher, da es auf unserem Modell plant, welches neben dem UR5 auch noch den PG70 samt Greiferfinger und Zwischenstück sowie den Tisch beinhaltet. Auch die IK wird von MoveIt gelöst. Es wird also online eine Abfolge von Gelenkpositionen für den UR5 bestimmt und abgefahren. \textit{cup\_acceptor\_pathing} beinhaltet dabei zwei Actions. Die \textit{plan\_and\_execute} berechnet mit \textit{compute\_cartesian\_path} über die Wegpunkt eine Trajektorie und führt sie aus, wohingegen \textit{go\_home} den Roboterarm in die Home-Konfiguration führt. Dabei wird \textit{set\_pose\_target} und \textit{plan} verwendet.
\newline \\
Die gesamte Bahnplanungskomponente besitzt dabei außerdem eine vollständige Fehlererkennung, sowie Fallback-Protokolle für die einzelnen Etappen im Ablauf. Die beiden Actions von \textit{cup\_acceptor\_pathing} können neben dem Ergebnis-Code 200 für Erfolg auch noch 500 für Misserfolg zurück liefern. In diesem Fall fängt \textit{cup\_acceptor\_planning} dies ab und weiß, dass die Bahnplanung fehlschlug. Je nachdem, in welchem Abschnitt sich der UR5 mit der Tasse befindet, wird ein dementsprechendes Protokoll abgespielt, nachdem sich der Roboterarm wieder in Home-Konfiguration und die Tasse wieder in initialer Pose auf dem Tisch befindet. Zusätzlich stellt die Planungskomponente am Anfang der Durchführung sicher, dass sowohl die Tasse als auch der Turtlebot erreichbar ist. Dies wird einfachheitshalber über die kartesische Distanz überprüft. Sollte sich eins von beidem zu weit entfernt befinden, so wird der Ergebnis-Code 301 bzw. 302 an die Highlevel-Steuerung zurückgeliefert.
