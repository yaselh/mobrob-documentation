Die gesamte Bahnplanungskomponente besteht aus zwei Paketen:
\begin{enumerate}
	\item \textit{cup\_acceptor\_planning}:
				\newline
				Erhält von der Highlevel-Steuerung die Posen der Tasse und des Turtlebots. Setzt Zwischenwegpunkt für die Trajektorienbestimmung. Regelt den Ablauf zwischen der Steuerung des UR5 und des PG70.
	\item \textit{cup\_acceptor\_pathing}:
				\newline
				Initialisiert MoveIt. Erhält von \textit{cup\_acceptor\_planning} eine Liste von Wegpunkten. Bestimmt mit auszuführende Trajektorie für die gegebenen Wegpunkt und führt sie auf dem UR5 aus.
\end{enumerate}
\textit{cup\_acceptor\_planning} stellt die Logik hinter der Bahnplanung dar. Sie startet Actions von \textit{cup\_acceptor\_pathing}, sowie \textit{cup\_gripper} und regelt das Zusammenspiel dieser beiden ROS-Pakete. Zunächst stellt sie sicher, dass der Roboterarm samt PG70 sich in Home-Konfiguration befinden. Danach wird zunächst der UR5 zur Tasse bewegt. Dann wird der PG70 angesteuert, um die Tasse zu greifen. Anschließend wird die Tasse zum Turtlebot geführt und dort wieder losgelassen. Letztendlich soll der Roboterarm wieder in die Home-Konfiguration zurückkehren. Für den Bahnplanungsablauf wird von \textit{cup\_acceptor\_planning} dabei neben den Posen der Tasse und des Turtlebots auch noch je ein Punkt direkt über den beiden Zielen gesetzt und zwar so, dass sich der EEF des Roboterarms einige Zentimeter über der oberen Kante der Tasse bzw. der Tischplatte befindet. \textit{cup\_acceptor\_planning} stellt eine einzige Action bereit, welche die oben beschriebene Logik ausführt. 
\newline
\textit{cup\_acceptor\_pathing} ist für die eigentliche Bahnplanung und Ansteuerung der Hardware mit MoveIt zuständig. Da wir die Bahnplanung in Python implementierten, mussten wir das ROS-Paket \glqq Moveit\_Commander\grqq \cite{MoveItCommander} zu unserem Projekt hinzufügen. \textit{cup\_acceptor\_pathing} erhält also eine Liste von EEF-Posen, über die es eine Trajektorie berechnen soll, welche vom UR5 ohne Kollisionen abgefahren werden kann. Dazu wird MoveIt verwendet. MoveIt stellt dabei einen kollisionsfreien Pfad sicher, da es auf unserem Modell plant, welches neben dem UR5 auch noch den PG70 samt Greiferfinger und Zwischenstück sowie den Tisch beinhaltet. Auch die IK wird von MoveIt gelöst. Es wird also online eine Abfolge von Gelenkpositionen für den UR5 bestimmt und abgefahren. \textit{cup\_acceptor\_pathing} beinhaltet dabei zwei Actions. Die \textit{plan\_and\_execute} berechnet mit \textit{compute\_cartesian\_path} über die Wegpunkt eine Trajektorie und führt sie aus, wohingegen \textit{go\_home} den Roboterarm in die Home-Konfiguration führt. Dabei wird \textit{set\_target\_pose} und \textit{plan} verwendet.
\newline
Die gesamte Bahnplanungskomponente besitzt dabei außerdem eine vollständige Fehlererkennung, sowie Fallback-Protokolle für die einzelnen Etappen im Ablauf. Die beiden Actions von \textit{cup\_acceptor\_pathing} können neben dem Ergebnis-Code 200 für Erfolg auch noch 500 für Misserfolg zurück liefern. In diesem Fall fängt \textit{cup\_acceptor\_planning} dies ab und weiß, dass die Bahnplanung fehlschlug. Je nachdem, in welchem Abschnitt sich der UR5 mit der Tasse befindet, wird ein dementsprechendes Protokoll abgespielt, nachdem sich der Roboterarm wieder in HOME-Konfiguration und die Tasse wieder in initialer Pose auf dem Tisch befindet. Zusätzlich stellt die Planungskomponente am Anfang der Durchführung sicher, dass sowohl die Tasse als auch der Turtlebot erreichbar ist. Dies wird einfachheitshalber über die kartesische Distanz überprüft. Sollte sich eins von beidem zu weit entfernt befinden, so wird der Ergebnis-Code 301 bzw. 302 an die Highlevel-Steuerung zurückgeliefert.
